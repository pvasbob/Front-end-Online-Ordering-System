localStorage in the browser is scoped per origin (protocol + domain + port), not per page.

That means:

Any page on the same origin (e.g. https://example.com/page1.html and https://example.com/page2.html) can read/write the same localStorage.

Different origins get completely separate storage (e.g. https://example.com vs. https://sub.example.com or http://example.com).

Closing/reopening the browser does not clear it (unless the user manually clears or you use sessionStorage instead).


===============================================

JavaScript Modules (type="module)

Entry point: Only the main script needs to be in HTML with <script type="module" src="main.js"></script>.

Imports automatically load modules: Any import { ... } from "./cart.js" causes the browser to fetch cart.js as a module automatically. You don’t need to put cart.js in HTML.

Top-level code execution: All code at the top level in cart.js (not inside functions) runs once when first imported. If multiple modules import the same module, it does not re-run — the same module instance is reused.

Exports: export allows other modules to access functions, variables, or objects from this module. Modules have their own scope; variables don’t leak to window.

===============================================

Each HTML page has its own separate JavaScript environment. “Global” only means global within that page.

===============================================

ESM = EcmaScript Module
EcmaScript is another name of JavaScript

===============================================

Default export (only one per file, name chosen by the importer).
A module can have only one default export.

Named exports (zero or more per file, must match the given names).
A module can have many named exports.

===============================================

1. Update the data
2. Regenerate all the HTML 
 = MVC 
 = Model - View - Controller

split code into 3 parts:
1. Model = saves and manages the data
2. View = takes the data and displays it on the page
3. Controller = runs some code when we interact with the page. 

MVC is a design pattern, makes sure the page always mathces the data.

===============================================

1. Save the data          Model
2. Generate the HTML      View
3. Make it interactive    Controller

===============================================

group of related tests = test suite

===============================================

in jasmine, spec = test

===============================================

Flaky Test = test that sometimes passes and sometimes fails
Mocks = lets us replace a method with a fake version. 

Test cases and test suites
Testing Framework
Mock and spy on methods
Test web pages using integration tests
Hooks

===============================================

let cart;
is a shorthand for :
let cart = undefined; 

===============================================

in an object you can not use 'export', 'let'

in an object, the definition of a function needs to use 
regular function syntax, not an arrow function. This is usual called a method. 

In defining a method in object, there is a shorthand:

loadFromStorage: function() {}
loadFromStorage() {}

===============================================

'this' used inside a method or inside a regular funcion. 

when 'this' is used inside method which is inside an class, 
  'this' points to the object.

Third situation is, when 'this' is used inside a arrow function.  'this' will keep the value outside the arrow function. This design is to avoid override the 'this'.


when 'this' is used inside a regular function (not inside a class), 'this' is undefined by default. 

But, if the regular function called .call('xxx') like below:

functionName.call('hell')
then the 'this' will be replaced by 'hello'. 

This is equivalent to say that, by using .call(), we can add extra paramter to a function, should, say, we temporarily need an extra parameter and we dont want to rewrite a function definition. 


1. Inside a method, 'this' points to the outer object.
2. Inside a function, this = undefined.
    But we can change it to whatever we want, by using .call().
3. Arrow functions do not change the value of 'this'. 

The rule is: 
  If there is an object to point to, 'this' will point to the object. 
  If there is no object to point to, 'this' will be undefined, and we have tools like .call() and arrow function to help manipulate the value of 'this' to be what we want. 

===============================================

Polymorphisum = calling a method without needing to know the classes.

===============================================

backend = another computer that manages the data of a website.
Callback = a function to run in the future.

===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================
===============================================